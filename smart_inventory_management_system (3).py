# -*- coding: utf-8 -*-
"""Smart inventory management system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_UsqydbVR46U4xJqug959VFmRoiIt8H8
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
np.random.seed(42)

dates = pd.date_range(start='2023-01-01', end='2023-12-31', freq='D')

num_products = 5

products = []
for i in range(num_products):
    product_id = f'P{i+1}'
    product_name = f'Product_{i+1}'
    category = np.random.choice(['Category_A', 'Category_B', 'Category_C'])
    supplier_id = f'S{i+1}'
    supplier_lead_time = np.random.randint(3, 10)
    reorder_quantity = np.random.randint(50, 200)
    unit_price = np.random.uniform(10, 50)
    holding_cost = np.random.uniform(0.1, 0.5)
    order_cost = np.random.uniform(20, 100)
    stockout_cost = np.random.uniform(10, 50)
    demand_variability = np.random.uniform(0.1, 0.3)

    for date in dates:
        sales_quantity = np.random.poisson(lam=100)
        products.append([
            date, product_id, product_name, category, supplier_id, supplier_lead_time,
            sales_quantity, reorder_quantity, unit_price, holding_cost, order_cost,
            stockout_cost, demand_variability
        ])

columns = [
    'date', 'product_id', 'product_name', 'category', 'supplier_id', 'supplier_lead_time',
    'sales_quantity', 'reorder_quantity', 'unit_price', 'holding_cost', 'order_cost',
    'stockout_cost', 'demand_variability'
]
data = pd.DataFrame(products, columns=columns)

initial_stock = 2000
data['stock_level'] = initial_stock - data.groupby('product_id')['sales_quantity'].cumsum()
data['stock_level'] = np.maximum(data['stock_level'], 0)
data['reorder_point'] = data['reorder_quantity'] * 0.2
data['lead_time'] = data['supplier_lead_time']

data.to_csv('enhanced_smart_inventory_management_data.csv', index=False)

print("Enhanced dataset created and saved to 'enhanced_smart_inventory_management_data.csv'")

df=pd.read_csv('enhanced_smart_inventory_management_data.csv')
df.all()

import pandas as pd
import numpy as np

def generate_enhanced_dataset():

    np.random.seed(42)

    dates = pd.date_range(start='2023-01-01', end='2023-12-31', freq='D')

    num_products = 5
    products = []
    for i in range(num_products):
        product_id = f'P{i+1}'
        product_name = f'Product_{i+1}'
        category = np.random.choice(['Category_A', 'Category_B', 'Category_C'])
        supplier_id = f'S{i+1}'
        supplier_lead_time = np.random.randint(3, 10)
        reorder_quantity = np.random.randint(50, 200)
        unit_price = np.random.uniform(10, 50)
        holding_cost = np.random.uniform(0.1, 0.5)
        order_cost = np.random.uniform(20, 100)
        stockout_cost = np.random.uniform(10, 50)
        demand_variability = np.random.uniform(0.1, 0.3)

        initial_stock = np.random.randint(1000, 3000)
        stock_level = initial_stock

        for date in dates:
            sales_quantity = np.random.poisson(lam=100)
            stock_level = max(stock_level - sales_quantity, 0)

            if stock_level < reorder_quantity:
                stock_level += reorder_quantity

            products.append([
                date, product_id, product_name, category, supplier_id, supplier_lead_time,
                sales_quantity, reorder_quantity, unit_price, holding_cost, order_cost,
                stockout_cost, demand_variability, stock_level
            ])


    columns = [
        'date', 'product_id', 'product_name', 'category', 'supplier_id', 'supplier_lead_time',
        'sales_quantity', 'reorder_quantity', 'unit_price', 'holding_cost', 'order_cost',
        'stockout_cost', 'demand_variability', 'stock_level'
    ]
    data = pd.DataFrame(products, columns=columns)

    data['reorder_point'] = data['reorder_quantity'] * 0.2
    data['lead_time'] = data['supplier_lead_time']

    return data
data = generate_enhanced_dataset()

data.to_csv('enhanced_smart_inventory_management_data.csv', index=False)

print("Enhanced dataset created and saved to 'enhanced_smart_inventory_management_data.csv'")
df=pd.read_csv('enhanced_smart_inventory_management_data.csv')
df.all()

X = data.drop(['sales_quantity', 'product_name'], axis=1)
y = data['sales_quantity']

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

import xgboost as xgb
model = xgb.XGBRegressor(objective='reg:squarederror', n_estimators=100, learning_rate=0.1)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

import numpy as np
mae = np.mean(np.abs(y_test - y_pred))
print(f"Mean Absolute Error of the Forecasting Model: {mae}")
from sklearn.preprocessing import LabelEncoder

label_encoder = LabelEncoder()
data['product_name_encoded'] = label_encoder.fit_transform(data['product_name'])

data = data.drop(['product_name'], axis=1)

X = data.drop(['sales_quantity'], axis=1)
y = data['sales_quantity']

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

import xgboost as xgb
model = xgb.XGBRegressor(objective='reg:squarederror', n_estimators=100, learning_rate=0.1)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

import numpy as np
mae = np.mean(np.abs(y_test - y_pred))
print(f"Mean Absolute Error of the Forecasting Model: {mae}")

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
import xgboost as xgb
from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

X = data.drop(['sales_quantity'], axis=1)
y = data['sales_quantity']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

model = xgb.XGBRegressor(objective='reg:squarederror', n_estimators=100, learning_rate=0.1)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

bins = [0, 50, 150, 300]
labels = ['low', 'medium', 'high']
y_test_category = pd.cut(y_test, bins=bins, labels=labels, right=False)
y_pred_category = pd.cut(y_pred, bins=bins, labels=labels, right=False)

conf_matrix = confusion_matrix(y_test_category, y_pred_category)

print("Confusion Matrix:")
print(conf_matrix)

plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=labels, yticklabels=labels)
plt.title("Confusion Matrix")
plt.xlabel("Predicted Categories")
plt.ylabel("Actual Categories")
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

inventory_data = {
    'product_id': ['P001', 'P002', 'P003'],
    'forecasted_demand': [100, 200, 150],
    'standard_deviation_demand': [10, 20, 15],
    'lead_time': [2, 3, 2],
    'ordering_cost': [50, 60, 40],
    'holding_cost': [2, 3, 2],
    'current_inventory': [150, 300, 200],
}

df = pd.DataFrame(inventory_data)

def calculate_safety_stock(std_demand, lead_time, service_level_factor=1.96):
    """
    Calculate Safety Stock.
    :param std_demand: Standard deviation of demand
    :param lead_time: Lead time in weeks
    :param service_level_factor: Z value corresponding to the service level (default: 1.96 for 97.5% service level)
    :return: Safety Stock
    """
    safety_stock = service_level_factor * std_demand * np.sqrt(lead_time)
    return safety_stock

def calculate_eoq(demand, ordering_cost, holding_cost):
    """
    Calculate Economic Order Quantity (EOQ).
    :param demand: Forecasted demand (units per period)
    :param ordering_cost: Cost to place one order
    :param holding_cost: Holding cost per unit per period
    :return: Optimal order quantity (EOQ)
    """
    eoq = np.sqrt((2 * demand * ordering_cost) / holding_cost)
    return eoq

df['safety_stock'] = df.apply(lambda x: calculate_safety_stock(x['standard_deviation_demand'], x['lead_time']), axis=1)
df['eoq'] = df.apply(lambda x: calculate_eoq(x['forecasted_demand'], x['ordering_cost'], x['holding_cost']), axis=1)

df['recommended_order_quantity'] = df['eoq'] - df['current_inventory'] + df['safety_stock']

print(df[['product_id', 'safety_stock', 'eoq', 'recommended_order_quantity']])

plt.figure(figsize=(10, 6))
for i, row in df.iterrows():
    plt.bar(row['product_id'], row['recommended_order_quantity'], label=f"Product {row['product_id']}")
plt.title("Recommended Replenishment Quantities")
plt.xlabel("Product ID")
plt.ylabel("Recommended Order Quantity")
plt.legend()
plt.show()

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

inventory_data = {
    'product_id': ['P001', 'P002', 'P003'],
    'product_name': ['Product A', 'Product B', 'Product C'],
    'forecasted_demand': [100, 200, 150],
    'standard_deviation_demand': [10, 20, 15],
    'lead_time': [2, 3, 2],
    'ordering_cost': [50, 60, 40],
    'holding_cost': [2, 3, 2],
    'current_inventory': [150, 300, 200],
}

df = pd.DataFrame(inventory_data)

def calculate_safety_stock(std_demand, lead_time, service_level_factor=1.96):
    """
    Calculate Safety Stock.
    :param std_demand: Standard deviation of demand
    :param lead_time: Lead time in weeks
    :param service_level_factor: Z value corresponding to the service level (default: 1.96 for 97.5% service level)
    :return: Safety Stock
    """
    safety_stock = service_level_factor * std_demand * np.sqrt(lead_time)
    return safety_stock

def calculate_eoq(demand, ordering_cost, holding_cost):
    """
    Calculate Economic Order Quantity (EOQ).
    :param demand: Forecasted demand (units per period)
    :param ordering_cost: Cost to place one order
    :param holding_cost: Holding cost per unit per period
    :return: Optimal order quantity (EOQ)
    """
    eoq = np.sqrt((2 * demand * ordering_cost) / holding_cost)
    return eoq

df['safety_stock'] = df.apply(lambda x: calculate_safety_stock(x['standard_deviation_demand'], x['lead_time']), axis=1)
df['eoq'] = df.apply(lambda x: calculate_eoq(x['forecasted_demand'], x['ordering_cost'], x['holding_cost']), axis=1)

df['recommended_order_quantity'] = df['eoq'] - df['current_inventory'] + df['safety_stock']

df['reorder_point'] = df['forecasted_demand'] * df['lead_time'] + df['safety_stock']

st.title('Smart Inventory Management System')

st.subheader('Inventory Data and Optimization Recommendations')
st.write(df[['product_name', 'current_inventory', 'forecasted_demand', 'safety_stock', 'eoq', 'recommended_order_quantity', 'reorder_point']])

st.subheader('Replenishment Recommendations Visualization')
fig, ax = plt.subplots(figsize=(10, 6))
ax.bar(df['product_name'], df['recommended_order_quantity'], color='blue', alpha=0.7, label="Recommended Order Quantity")
ax.bar(df['product_name'], df['current_inventory'], color='green', alpha=0.7, label="Current Inventory")
ax.set_title("Inventory vs Recommended Replenishment")
ax.set_xlabel("Products")
ax.set_ylabel("Quantity")
ax.legend(loc='upper left')
st.pyplot(fig)

st.subheader('Potential Stockouts and Actions')
for index, row in df.iterrows():
    if row['current_inventory'] < row['reorder_point']:
        st.warning(f"{row['product_name']}** is at risk of stockout. Reorder recommended!")
    else:
        st.success(f"{row['product_name']}** has sufficient stock.")

st.subheader('Actionable Insights')
st.markdown("""
- *Replenishment Recommendations*: The recommended order quantities suggest how much stock to order based on forecasted demand and safety stock.
- *Stockout Risk*: Products with current inventory below the reorder point are at risk of stockouts and need immediate attention.
- *EOQ and Safety Stock*: Ensure that you maintain an optimal order quantity and safety stock level to reduce both holding and ordering costs.
""")

import pandas as pd
import numpy as np
data = {
    'product_id': ['P001', 'P002', 'P003'],
    'product_name': ['Product A', 'Product B', 'Product C'],
    'sales_data': [200, 150, 300],
    'date': pd.to_datetime(['2023-01-01', '2023-01-02', '2023-01-03']),
}

df = pd.DataFrame(data)
df['week'] = df['date'].dt.isocalendar().week
df['month'] = df['date'].dt.month
df.fillna(0, inplace=True)

print("Transformed Data:")
print(df)

df_transformed = df.copy()

df_transformed.to_csv("transformed_inventory_data.csv", index=False)

print("\nTransformed Data saved to 'transformed_inventory_data.csv'")

import pandas as pd
import numpy as np
import xgboost as xgb
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt

sales_data = {
    'date': pd.to_datetime(['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05']),
    'sales': [200, 150, 300, 250, 220],
}

df = pd.DataFrame(sales_data)

df['day'] = df['date'].dt.day
df['week'] = df['date'].dt.isocalendar().week
df['month'] = df['date'].dt.month

X = df[['day', 'week', 'month']]
y = df['sales']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = xgb.XGBRegressor(objective='reg:squarederror', n_estimators=100, learning_rate=0.1)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

print(f'Mean Absolute Error (MAE): {mae}')
print(f'Root Mean Squared Error (RMSE): {rmse}')

plt.figure(figsize=(10, 6))
plt.plot(y_test.values, label='Actual Sales')
plt.plot(y_pred, label='Predicted Sales', linestyle='--')
plt.legend()
plt.title("Actual vs Predicted Sales")
plt.xlabel("Test Data Points")
plt.ylabel("Sales")
plt.show()

import pandas as pd
import numpy as np

forecasted_sales = [200, 150, 300, 250, 220, 300, 400, 450, 500, 550, 600, 450, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950, 1000, 1050, 1100, 1200, 1150, 1250, 1300, 1350, 1400]

avg_demand = np.mean(forecasted_sales)
std_dev_demand = np.std(forecasted_sales)

lead_time = 5

Z = 1.65
safety_stock = Z * std_dev_demand * np.sqrt(lead_time)
reorder_point = avg_demand * lead_time + safety_stock

ordering_cost = 50
holding_cost_per_unit = 2

annual_demand = avg_demand * 365

EOQ = np.sqrt((2 * annual_demand * ordering_cost) / holding_cost_per_unit)

print(f"Average Demand: {avg_demand:.2f} units/day")
print(f"Standard Deviation of Demand: {std_dev_demand:.2f} units/day")
print(f"Safety Stock: {safety_stock:.2f} units")
print(f"Reorder Point: {reorder_point:.2f} units")
print(f"Economic Order Quantity (EOQ): {EOQ:.2f} units")

recommended_order_quantity = EOQ
print(f"\nRecommended Order Quantity (EOQ): {recommended_order_quantity:.2f} units")

print(f"Reorder Point: When inventory drops below {reorder_point:.2f} units, it's time to reorder.")

import pandas as pd
import numpy as np
import plotly.express as px
data = {
    'product_id': ['P001', 'P002', 'P003', 'P004', 'P005'],
    'product_name': ['Product A', 'Product B', 'Product C', 'Product D', 'Product E'],
    'category': ['Category 1', 'Category 2', 'Category 3', 'Category 1', 'Category 2'],
    'current_stock': [100, 50, 150, 200, 80],
    'sales_forecast': [80, 60, 130, 190, 100],
    'reorder_point': [60, 40, 120, 180, 70],
    'lead_time': [5, 3, 4, 7, 6]
}

df = pd.DataFrame(data)
df['safety_stock'] = df['sales_forecast'] * 0.1
df['stockout_risk'] = df['current_stock'] - df['sales_forecast']

df

fig1 = px.bar(df, x='product_name', y=['current_stock', 'sales_forecast'],
              title="Inventory Levels vs Forecasted Demand",
              labels={'product_name': 'Product', 'value': 'Quantity'},
              barmode='group')

fig1.show()
fig2 = px.bar(df, x='product_name', y=['current_stock', 'reorder_point'],
              title="Reorder Point vs Current Stock",
              labels={'product_name': 'Product', 'value': 'Quantity'},
              barmode='group')

fig2.show()
fig3 = px.bar(df, x='product_name', y='stockout_risk',
              title="Stockout Risk (Current Stock - Forecasted Demand)",
              labels={'product_name': 'Product', 'value': 'Stockout Risk'},
              color='stockout_risk',
              color_continuous_scale='Viridis')

fig3.show()
df['actionable_insights'] = df.apply(lambda row: 'Restock Immediately' if row['stockout_risk'] < 0 else 'Stock Sufficient', axis=1)

df[['product_name', 'stockout_risk', 'actionable_insights']]

import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go

data = {
    'product_id': ['P001', 'P002', 'P003', 'P004', 'P005'],
    'product_name': ['Product A', 'Product B', 'Product C', 'Product D', 'Product E'],
    'category': ['Category 1', 'Category 2', 'Category 3', 'Category 1', 'Category 2'],
    'current_stock': [100, 50, 150, 200, 80],
    'sales_forecast': [80, 60, 130, 190, 100],
    'reorder_point': [60, 40, 120, 180, 70],
    'lead_time': [5, 3, 4, 7, 6]
}

df = pd.DataFrame(data)

df['safety_stock'] = df['sales_forecast'] * 0.1
df['stockout_risk'] = df['current_stock'] - df['sales_forecast']


df
fig1 = px.bar(df, x='product_name', y=['current_stock', 'sales_forecast'],
              title="Inventory Levels vs Forecasted Demand",
              labels={'product_name': 'Product', 'value': 'Quantity'},
              barmode='group')

fig1.show()

fig2 = px.bar(df, x='product_name', y=['current_stock', 'reorder_point'],
              title="Reorder Point vs Current Stock",
              labels={'product_name': 'Product', 'value': 'Quantity'},
              barmode='group')

fig2.show()

fig3 = px.bar(df, x='product_name', y='stockout_risk',
              title="Stockout Risk (Current Stock - Forecasted Demand)",
              labels={'product_name': 'Product', 'value': 'Stockout Risk'},
              color='stockout_risk',
              color_continuous_scale='Viridis')

fig3.show()

fig4 = px.bar(df, x='product_name', y=['current_stock', 'safety_stock'],
              title="Safety Stock vs Current Stock",
              labels={'product_name': 'Product', 'value': 'Quantity'},
              barmode='group')

fig4.show()

df['actionable_insights'] = df.apply(lambda row: 'Restock Immediately' if row['stockout_risk'] < 0 else 'Stock Sufficient', axis=1)

df[['product_name', 'stockout_risk', 'actionable_insights']]

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go

def generate_data():
    forecasted_sales = [200, 150, 300, 250, 220, 300, 400, 450, 500, 550, 600, 450, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950, 1000, 1050, 1100, 1200, 1150, 1250, 1300, 1350, 1400]
    inventory_levels = np.random.randint(low=1500, high=2000, size=30)
    return forecasted_sales, inventory_levels

forecasted_sales, inventory_levels = generate_data()

st.sidebar.header("Inventory Management Dashboard")
st.sidebar.subheader("Parameters for Forecasting")
lead_time = st.sidebar.slider("Lead Time (in days)", 1, 10, 5)

st.title("Smart Inventory Management Dashboard")

st.subheader("Inventory Levels vs Forecasted Demand")
fig, ax = plt.subplots(figsize=(10, 6))

days = range(30)
ax.plot(days, forecasted_sales[:30], label='Forecasted Sales', marker='o', color='b')
ax.plot(days, inventory_levels[:30], label='Inventory Levels', marker='x', color='r')
ax.set_xlabel("Days")
ax.set_ylabel("Units")
ax.set_title("Inventory Levels vs Forecasted Sales")
ax.legend()
st.pyplot(fig)

avg_demand = np.mean(forecasted_sales)
std_dev_demand = np.std(forecasted_sales)

Z = 1.65
safety_stock = Z * std_dev_demand * np.sqrt(lead_time)
reorder_point = avg_demand * lead_time + safety_stock

ordering_cost = 50
holding_cost_per_unit = 2
annual_demand = avg_demand * 365
EOQ = np.sqrt((2 * annual_demand * ordering_cost) / holding_cost_per_unit)

st.subheader("Inventory Optimization Metrics")
st.write(f"*Average Demand:* {avg_demand:.2f} units/day")
st.write(f"*Standard Deviation of Demand:* {std_dev_demand:.2f} units/day")
st.write(f"*Safety Stock:* {safety_stock:.2f} units")
st.write(f"*Reorder Point:* {reorder_point:.2f} units")
st.write(f"*Economic Order Quantity (EOQ):* {EOQ:.2f} units")

st.subheader("Inventory Replenishment Recommendations")
st.write(f"To avoid stockouts, reorder when inventory falls below {reorder_point:.2f} units.")
st.write(f"The optimal order quantity is {EOQ:.2f} units.")

data = {
    "Metric": ["Average Demand", "Safety Stock", "Reorder Point", "EOQ"],
    "Value": [f"{avg_demand:.2f} units/day", f"{safety_stock:.2f} units", f"{reorder_point:.2f} units", f"{EOQ:.2f} units"]
}

df = pd.DataFrame(data)

st.subheader("Actionable Insights")
st.dataframe(df)

fig_table = go.Figure(data=[go.Table(
    header=dict(values=["Metric", "Value"]),
    cells=dict(values=[data["Metric"], data["Value"]]))])

st.plotly_chart(fig_table)


st.markdown("""
    ### How to Use This Dashboard:
    - Monitor *inventory levels* in comparison with *forecasted sales*.
    - Review *replenishment recommendations* for optimal inventory levels.
    - Get *actionable insights* for improving stock management.
""")